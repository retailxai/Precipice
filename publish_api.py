#!/usr/bin/env python3
"""
RetailXAI Publishing API
Handles publishing drafts to various channels (Substack, LinkedIn, Twitter, etc.)
"""

import json
import os
import sys
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import requests
import tweepy
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import smtplib

# Add the project root to Python path
sys.path.insert(0, str(Path(__file__).parent))

from dotenv import load_dotenv

# Load environment variables
load_dotenv('config/.env')

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('RetailXAI.PublishAPI')

class PublishingAPI:
    """Handles publishing content to various channels."""
    
    def __init__(self):
        self.config = self._load_config()
        self.twitter_api = self._setup_twitter()
        self.email_config = self._setup_email()
        
    def _load_config(self) -> Dict:
        """Load configuration from environment variables."""
        return {
            'twitter': {
                'consumer_key': os.getenv('TWITTER_CONSUMER_KEY'),
                'consumer_secret': os.getenv('TWITTER_CONSUMER_SECRET'),
                'access_token': os.getenv('TWITTER_ACCESS_TOKEN'),
                'access_token_secret': os.getenv('TWITTER_ACCESS_TOKEN_SECRET')
            },
            'email': {
                'smtp_server': 'smtp.gmail.com',
                'smtp_port': 587,
                'username': os.getenv('DAILY_REPORT_SENDER'),
                'password': os.getenv('DAILY_REPORT_PASSWORD'),
                'recipient': os.getenv('DRAFT_EMAIL_RECIPIENT')
            },
            'substack': {
                'email': os.getenv('DRAFT_EMAIL_RECIPIENT')
            }
        }
    
    def _setup_twitter(self) -> Optional[tweepy.API]:
        """Set up Twitter API client."""
        try:
            auth = tweepy.OAuthHandler(
                self.config['twitter']['consumer_key'],
                self.config['twitter']['consumer_secret']
            )
            auth.set_access_token(
                self.config['twitter']['access_token'],
                self.config['twitter']['access_token_secret']
            )
            return tweepy.API(auth)
        except Exception as e:
            logger.error(f"Failed to setup Twitter API: {e}")
            return None
    
    def _setup_email(self) -> Dict:
        """Set up email configuration."""
        return self.config['email']
    
    def publish_to_twitter(self, content: str, draft_id: int) -> Dict:
        """Publish content to Twitter."""
        try:
            if not self.twitter_api:
                return {'success': False, 'error': 'Twitter API not configured'}
            
            # Truncate content to Twitter's character limit
            if len(content) > 280:
                content = content[:277] + '...'
            
            # Post tweet
            tweet = self.twitter_api.update_status(content)
            
            logger.info(f"Published tweet {tweet.id} for draft {draft_id}")
            return {
                'success': True,
                'tweet_id': tweet.id,
                'url': f"https://twitter.com/user/status/{tweet.id}"
            }
            
        except Exception as e:
            logger.error(f"Failed to publish to Twitter: {e}")
            return {'success': False, 'error': str(e)}
    
    def publish_to_linkedin(self, content: Dict, draft_id: int) -> Dict:
        """Publish content to LinkedIn (via email for now)."""
        try:
            # For now, we'll send LinkedIn content via email
            # In a real implementation, you'd use LinkedIn's API
            
            subject = f"LinkedIn Post - {content.get('headline', 'RetailXAI Content')}"
            body = f"""
LinkedIn Post Content:

Headline: {content.get('headline', '')}
Summary: {content.get('summary', '')}

Post Text:
{content.get('linkedin_post', content.get('body', ''))}

Key Insights:
{chr(10).join(f"â€¢ {insight}" for insight in content.get('key_insights', []))}

---
Generated by RetailXAI Dashboard
Draft ID: {draft_id}
Timestamp: {datetime.now().isoformat()}
            """
            
            self._send_email(subject, body)
            
            logger.info(f"Sent LinkedIn content via email for draft {draft_id}")
            return {
                'success': True,
                'message': 'LinkedIn content sent via email for manual posting'
            }
            
        except Exception as e:
            logger.error(f"Failed to publish to LinkedIn: {e}")
            return {'success': False, 'error': str(e)}
    
    def publish_to_substack(self, content: Dict, draft_id: int) -> Dict:
        """Publish content to Substack (via email)."""
        try:
            # Generate HTML content for Substack
            html_content = self._generate_substack_html(content)
            
            subject = f"Substack Newsletter - {content.get('headline', 'RetailXAI Analysis')}"
            body = f"""
Substack Newsletter Content:

{html_content}

---
Generated by RetailXAI Dashboard
Draft ID: {draft_id}
Timestamp: {datetime.now().isoformat()}
            """
            
            self._send_email(subject, body, is_html=True)
            
            logger.info(f"Sent Substack content via email for draft {draft_id}")
            return {
                'success': True,
                'message': 'Substack content sent via email for manual posting'
            }
            
        except Exception as e:
            logger.error(f"Failed to publish to Substack: {e}")
            return {'success': False, 'error': str(e)}
    
    def _generate_substack_html(self, content: Dict) -> str:
        """Generate HTML content for Substack."""
        headline = content.get('headline', 'RetailXAI Analysis')
        body = content.get('body', content.get('summary', ''))
        insights = content.get('key_insights', [])
        
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>{headline}</title>
    <meta charset="UTF-8">
</head>
<body>
    <h1>{headline}</h1>
    <div style="font-family: Georgia, serif; line-height: 1.6; max-width: 600px;">
        {body}
    </div>
"""
        
        if insights:
            html += """
    <h2>Key Insights</h2>
    <ul>
"""
            for insight in insights:
                html += f"        <li>{insight}</li>\n"
            html += "    </ul>\n"
        
        html += f"""
    <hr>
    <p><em>Generated by RetailXAI on {datetime.now().strftime('%B %d, %Y at %I:%M %p')}</em></p>
</body>
</html>
"""
        return html
    
    def _send_email(self, subject: str, body: str, is_html: bool = False) -> bool:
        """Send email with the content."""
        try:
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.email_config['username']
            msg['To'] = self.email_config['recipient']
            
            if is_html:
                msg.attach(MIMEText(body, 'html'))
            else:
                msg.attach(MIMEText(body, 'plain'))
            
            server = smtplib.SMTP(self.email_config['smtp_server'], self.email_config['smtp_port'])
            server.starttls()
            server.login(self.email_config['username'], self.email_config['password'])
            server.send_message(msg)
            server.quit()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return False
    
    def get_drafts(self) -> List[Dict]:
        """Get all available drafts."""
        try:
            drafts = []
            
            # Load from drafts directory
            drafts_dir = Path('drafts')
            if drafts_dir.exists():
                for draft_file in drafts_dir.rglob('*.json'):
                    try:
                        with open(draft_file, 'r') as f:
                            draft_data = json.load(f)
                            draft_data['id'] = len(drafts) + 1
                            draft_data['file_path'] = str(draft_file)
                            drafts.append(draft_data)
                    except Exception as e:
                        logger.warning(f"Failed to load draft {draft_file}: {e}")
            
            # Load from test_drafts directory
            test_drafts_dir = Path('test_drafts')
            if test_drafts_dir.exists():
                for draft_file in test_drafts_dir.rglob('*.json'):
                    try:
                        with open(draft_file, 'r') as f:
                            draft_data = json.load(f)
                            draft_data['id'] = len(drafts) + 1
                            draft_data['file_path'] = str(draft_file)
                            drafts.append(draft_data)
                    except Exception as e:
                        logger.warning(f"Failed to load test draft {draft_file}: {e}")
            
            return drafts
            
        except Exception as e:
            logger.error(f"Failed to get drafts: {e}")
            return []
    
    def publish_draft(self, draft_id: int, channel: str) -> Dict:
        """Publish a specific draft to a specific channel."""
        try:
            drafts = self.get_drafts()
            draft = next((d for d in drafts if d['id'] == draft_id), None)
            
            if not draft:
                return {'success': False, 'error': 'Draft not found'}
            
            # Route to appropriate publisher
            if channel == 'twitter':
                return self.publish_to_twitter(draft.get('linkedin_post', draft.get('body', '')), draft_id)
            elif channel == 'linkedin':
                return self.publish_to_linkedin(draft, draft_id)
            elif channel == 'substack':
                return self.publish_to_substack(draft, draft_id)
            else:
                return {'success': False, 'error': f'Unknown channel: {channel}'}
                
        except Exception as e:
            logger.error(f"Failed to publish draft {draft_id} to {channel}: {e}")
            return {'success': False, 'error': str(e)}

def main():
    """Main function for testing the publishing API."""
    api = PublishingAPI()
    
    # Test getting drafts
    print("Available drafts:")
    drafts = api.get_drafts()
    for draft in drafts:
        print(f"  ID: {draft['id']}, Title: {draft.get('headline', 'Untitled')}")
    
    # Test publishing (uncomment to test)
    # if drafts:
    #     result = api.publish_draft(drafts[0]['id'], 'linkedin')
    #     print(f"Publish result: {result}")

if __name__ == '__main__':
    main()
